---
title: "preprocess"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{preprocess}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(mikRopML)
```

Before running machine learning, it's often necessary and prudent to preprocess your input data. 
We provide a function (`preprocess_data`) to preprocess input data. 
The defaults we chose are based on best practices used in  [FIDDLE](https://gitlab.eecs.umich.edu/mld3/FIDDLE/-/tree/master/).
Feel free to check out FIDDLE for more information about data preprocessing!

The `preprocess_data` function takes an input dataset where the rows are the samples and the columns are the outcome variable and features and preprocess the data as follows:
- Removes missing outcome values. 
- Leavs binary features as-is (except that categorical variables are converted to 0 and 1).
- Normalizes continuous features using `caret::preProcess` based on the method provided.
- Converts categorical features with more than 2 variables to 0 and 1 in multiple columns (one for each variable - not full rank, so each variable has it's own column).
- Replaces missing categorical data with 0.
- Imputes missing continuous values with the median of the feature. 
- By default, removes all features with near-zero variance.
- By default, collapses correlated features.

# Examples

We're going to start off simple and get more complicated, but if you want the whole shebang at once, just scroll to the bottom.

## Binary data

Let's start with only binary variables:

```{r}
# raw binary dataset
bin_df <- data.frame(
  outcome = c("normal", "normal", "cancer"),
  var1 = c("no", "yes", "no"),
  var2 = c(0, 1, 1)
)
bin_df
```

Here's what the preprocessed data looks like:

```{r}
# preprocess raw binary data
preprocess_data(dataset = bin_df, outcome_colname = "outcome")
```

The output is a list of length two: `dat_transformed` which has the transformed data, and `grp_feats` which is a list of grouped features. Here, `grp_feats` is `NULL` because there are no perfectly correlated features (e.g. `c(0,1,0)` and `c(0,1,0)`, or `c(0,1,0)` and `c(1,0,1)` - see below for more details). 

The first column (`var1`) in `dat_transformed` is changed to `var1_yes` that has zeros (no) and ones (yes). The values in the second column (`var2`) stay the same because it's already binary, but the name changes to (`var2_1`). 

## Categorical data

On to non-binary categorical data:

```{r}
# raw categorical dataset
cat_df <- data.frame(
  outcome = c("normal", "normal", "cancer"),
  var1 = c('a','b','c')
  )
cat_df
```

```{r}
# preprocess raw categorical data
preprocess_data(dataset = cat_df, outcome_colname = "outcome")
```

As you can see, this variable was split into 3 different columns - one for each type (a, b, and c). And again, `grp_feats` is `NULL`.

## Continuous data

Now, looking at continuous variables:

```{r}
# raw continuous dataset
cont_df <- data.frame(
  outcome = c("normal", "normal", "cancer"),
  var1 = c(1,2,3)
  )
cont_df
```

```{r}
# preprocess raw continuous data
preprocess_data(dataset = cont_df, outcome_colname = "outcome")
```

Wow! Why did the numbers change? This is because the default is to normalize the data using `c("center","scale")`. While this is often best practice, you may not want to normalize the data, or you may want to normalize the data in a different way. If you don't want to normalize the data, you can use `method=NULL`:

```{r}
# preprocess raw continuous data, no normalization
preprocess_data(dataset = cont_df, outcome_colname = "outcome", method = NULL)
```

You can also normalize the data in different ways. You can implement any method used by the [`caret::preProcess`](https://www.rdocumentation.org/packages/caret/versions/6.0-86/topics/preProcess) function (the `method` argument).

Another feature of this function is that if you provide continuous variables as characters, they will be converted to numeric:

```{r}
# raw continuous dataset as characters
cont_char_df <- data.frame(
  outcome = c("normal", "normal", "cancer"),
  var1 = c("1","2","3")
  )
cont_char_df
```

```{r}
# preprocess raw continuous character data as numeric
preprocess_data(dataset = cont_char_df, outcome_colname = "outcome")
```

If you don't want this to happen, and you want character data to remain character data even if it can be converted to numeric, you can use `to_numeric=FALSE` and they will be kept as categorical:

```{r}
# preprocess raw continuous character data as characters
preprocess_data(dataset = cont_char_df, outcome_colname = "outcome", to_numeric = FALSE)
```

## Collapse perfectly correlated features

By default, the `preprocess_data` function collapses features that are perfectly positively or negatively correlated. 

## Data with near-zero variance

What if we have variables that are all zero, or all no? Those ones won't contribute any information, so we remove them:

```{r}
# raw dataset with non-variable features
nonvar_df <- data.frame(
  outcome = c("normal", "normal", "cancer"),
  var1 = c("no", "yes", "no"),
  var2 = c(0, 1, 1),
  var3 = c("no","no","no"),
  var4 = c(0,0,0),
  var5 = c(12,12,12)
)
nonvar_df
```

Here, `var3`, `var4`, and `var5` all have no variability, so these variables are removed during preprocessing:

```{r}
# remove features with near-zero variance
preprocess_data(dataset = nonvar_df, outcome_colname = "outcome")
```

You can read the [`caret::preProcess`](https://www.rdocumentation.org/packages/caret/versions/6.0-86/topics/preProcess) documentation for more information. If you want to include them, you can use the argument `remove_nzv=FALSE`. For this to work, you cannot collapse correlated features (otherwise it errors out because of the underlying `caret` function we use). 

```{r}
# don't remove features with near-zero variance
preprocess_data(dataset = nonvar_df, outcome_colname = "outcome", remove_nzv = FALSE, collapse_corr_feats = FALSE)
```

Note that if you want to remove zero variance features (rather than near-zero variance features), you can use `method = c('zv')`, and then you can collapse correlated features:

```{r}
# remove features with zero variance
preprocess_data(dataset = nonvar_df, outcome_colname = "outcome", method = c('zv'))
```

We'll use the following example raw data:

```{r}
test_df <- data.frame(
  outcome = c("normal", "normal", "cancer", NA),
  var1 = 1:4,
  var2 = c("a", "b", "c", "d"),
  var3 = c("no", "yes", "no", "no"),
  var4 = c(0, 1, 0, 0),
  var5 = c(0, 0, 0, 0),
  var6 = c("no", "no", "no", "no"),
  var7 = c(1, 1, 0, 0),
  var8 = c(5, 6, NA, 7),
  var9 = c(NA, "x", "y", "z"),
  var10 = c(1, 0, NA, NA),
  var11 = c(1, 1, NA, NA),
  var12 = c("1", "2", "3", "4")
)
test_df
```

Let's throw this into the preprocessing function without normalizing continuous variables or collapsing perfectly correlated features, so that we can more easily see what's going on. In addition to the dataframe itself, you have to provide the name of the outcome column. 

```{r}
preprocess_data(dataset = test_df, outcome_colname = "outcome", method = NULL, collapse_corr_feats = FALSE)
```

As you can see, we got several messages:
- One of the samples (row 4) was removed because the outcome value was missing.
- One of the variables in a feature with no variation had a missing value that was replaced with the the non-varying value (var11).
- Four categorical missing values were replaced with zero (var9). 
There are 4 missing rather than just 1 (like in the raw data) because we split the categorical variable into 4 different columns first.
- One missing continuous value was imputed using the median value of that feature (var8).

Additionally, you can see that all categorical features (when not grouped) contain an underscore with a number or category after the underscore (e.g. var3_yes, var4_1, var2_a). This is because the function makes binary categorical features into 0 or 1 (based on the variable after the underscore) and splits non-binary categorical features into separate columns. For istnace, `var3=c('no','yes','no')` goes to `var3_yes=c(0,1,0)`, and `var2=c('a','b','c')` goes to `var2_a=c(1,0,1)`

```{r}
test_that("preprocess_data works", {
  expect_equal(
    expect_message(, "Removed "),
    list(dat_transformed = structure(list(
      outcome = c(
        "normal", "normal",
        "cancer"
      ), var8 = c(-0.707106781186547, 0.707106781186547, 0),
      grp1 = c(-1, 0, 1), grp2 = c(0, 1, 0), grp3 = c(0, 0, 1),
      grp4 = c(1, 0, 0)
    ), row.names = c(NA, -3L), class = c(
      "tbl_df",
      "tbl", "data.frame"
    )), grp_feats = list(var8 = "var8", grp1 = c(
      "var12",
      "var1"
    ), grp2 = c("var4_1", "var3_yes", "var2_b", "var9_x", "var10_0"), grp3 = c("var2_c", "var7_1", "var9_y"), grp4 = c(
      "var10_1",
      "var2_a"
    )))
  )
  expect_equal(
    preprocess_data(test_df[1:3, c("outcome", "var1")], "outcome"),
    list(
      dat_transformed = dplyr::tibble(
        outcome = c("normal", "normal", "cancer"),
        var1 = c(-1, 0, 1),
      ),
      grp_feats = NULL
    )
  )
  expect_equal(
    preprocess_data(test_df[1:3, c("outcome", "var2")], "outcome"),
    list(
      dat_transformed = dplyr::tibble(
        outcome = c("normal", "normal", "cancer"),
        var2_a = c(1, 0, 0),
        var2_b = c(0, 1, 0),
        var2_c = c(0, 0, 1),
      ),
      grp_feats = NULL
    )
  )
  expect_equal(
    preprocess_data(test_df[1:3, c("outcome", "var3")], "outcome"),
    list(
      dat_transformed = dplyr::tibble(
        outcome = c("normal", "normal", "cancer"),
        var3_yes = c(0, 1, 0),
      ),
      grp_feats = NULL
    )
  )
  expect_equal(
    preprocess_data(test_df[1:3, c("outcome", "var4")], "outcome"),
    list(
      dat_transformed = dplyr::tibble(
        outcome = c("normal", "normal", "cancer"),
        var4_1 = c(0, 1, 0),
      ),
      grp_feats = NULL
    )
  )
  expect_equal(
    expect_message(preprocess_data(test_df[1:3, ], "outcome", method = NULL)),
    list(dat_transformed = structure(list(outcome = c(
      "normal", "normal",
      "cancer"
    ), var8 = c(5, 6, 5.5), grp1 = c(1, 2, 3), grp2 = c(
      0,
      1, 0
    ), grp3 = c(0, 0, 1), grp4 = c(1, 0, 0)), row.names = c(
      NA,
      -3L
    ), class = c("tbl_df", "tbl", "data.frame")), grp_feats = list(
      var8 = "var8", grp1 = c("var12", "var1"), grp2 = c(
        "var4_1",
        "var3_yes", "var2_b", "var9_x", "var10_0"
      ), grp3 = c(
        "var2_c",
        "var7_1", "var9_y"
      ), grp4 = c("var10_1", "var2_a")
    ))
  )
  expect_error(preprocess_data(test_df[1:3, c("outcome", "var5")], "outcome"))
  expect_equal(
    expect_message(preprocess_data(test_df[1:3, ], "outcome", method = c("range"))),
    list(dat_transformed = structure(list(outcome = c(
      "normal", "normal",
      "cancer"
    ), var8 = c(0, 1, 0.5), grp1 = c(0, 0.5, 1), grp2 = c(
      0,
      1, 0
    ), grp3 = c(0, 0, 1), grp4 = c(1, 0, 0)), row.names = c(
      NA,
      -3L
    ), class = c("tbl_df", "tbl", "data.frame")), grp_feats = list(
      var8 = "var8", grp1 = c("var12", "var1"), grp2 = c(
        "var4_1",
        "var3_yes", "var2_b", "var9_x", "var10_0"
      ), grp3 = c(
        "var2_c",
        "var7_1", "var9_y"
      ), grp4 = c("var10_1", "var2_a")
    ))
  )
  expect_error(
    preprocess_data(test_df[1:3, ], "outcome", remove_nzv = FALSE),
    "`remove_nzv` must be true if `collapse_corr_feats` is true. If you would like to group features based on correlation, please re-run this function with `remove_nzv` = TRUE"
  )
  expect_equal(
    expect_message(preprocess_data(test_df[1:3, ], "outcome", remove_nzv = FALSE, collapse_corr_feats = FALSE)),
    list(dat_transformed = structure(list(outcome = c(
      "normal", "normal",
      "cancer"
    ), var1 = c(-1, 0, 1), var8 = c(
      -0.707106781186547, 0.707106781186547,
      0
    ), var12 = c(-1, 0, 1), var3_yes = c(0, 1, 0), var4_1 = c(
      0,
      1, 0
    ), var7_1 = c(1, 1, 0), var2_a = c(1, 0, 0), var2_b = c(
      0,
      1, 0
    ), var2_c = c(0, 0, 1), var9_x = c(0, 1, 0), var9_y = c(
      0,
      0, 1
    ), var10_0 = c(0, 1, 0), var10_1 = c(1, 0, 0), var5 = c(
      0,
      0, 0
    ), var6 = c(0, 0, 0), var11 = c(1, 1, 1)), row.names = c(
      NA,
      -3L
    ), class = c("tbl_df", "tbl", "data.frame")), grp_feats = NULL)
  )
  expect_error(expect_message(preprocess_data(test_df[1:3, ], "outcome", method = c("asdf"))))
  expect_equal(
    expect_message(preprocess_data(test_df, "outcome", to_numeric = FALSE)),
    list(dat_transformed = structure(list(outcome = c(
      "normal", "normal",
      "cancer"
    ), var1 = c(-1, 0, 1), var8 = c(
      -0.707106781186547, 0.707106781186547,
      0
    ), grp1 = c(0, 1, 0), grp2 = c(1, 0, 0), grp3 = c(0, 0, 1)), row.names = c(
      NA,
      -3L
    ), class = c("tbl_df", "tbl", "data.frame")), grp_feats = list(
      var1 = "var1", var8 = "var8", grp1 = c(
        "var4_1", "var3_yes",
        "var2_b", "var9_x", "var10_0", "var12_2"
      ), grp2 = c(
        "var10_1",
        "var2_a", "var12_1"
      ), grp3 = c(
        "var2_c", "var7_1", "var9_y",
        "var12_3"
      )
    ))
  )
})

```

